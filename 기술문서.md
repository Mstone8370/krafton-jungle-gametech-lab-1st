
# 기술 문서

## 

* [ 01  ] 게임 잼
* [ 01+ ] 2D에서 3D로
* [ 02  ] UV, Billboard, Bounding Box, Batch Line
* [ 03  ] OBJ 파일 파싱을 통한 Static Mesh 임포트, 다중 뷰포트
* [ 04  ] 게임 잼 - Brute Force Competition (병목 및 최적화)
* [ 04+ ] Play In Editor
* [ 05  ] Pixel Shader (Fog, Post Process)
* [ 06  ] Light (Ambient, Directional, Point, Spot Light) + Light Culling
* [ 07  ] Shadow
* [ 08  ] 게임 잼 - Delegate (+ Component Overlap Event, Lua)
* [ 08+ ] Camera (Camera Shake, Letter Box, Fade In and Out, Spring Arm)
* [ 09  ] FBX (Bone, Skinning, Skeltal Mesh, CPU Skinning)
* [ 10  ] Animation (GPU Skinning), Animation Instance, Animation State Machine
* [ 11  ] Particle, Translucent Rendering
* [ 12  ] **DOF²** Depth of Field, Degree of Freedom (PhysX)
* [ 13  ] 게임 잼

---

## 2D에서 3D로
* MVP(Model View Projection)
  * 오브젝트의 정점의 스페이스를 변환.
  * 오브젝트 -> 월드 -> 뷰 -> NDC.
  * 한 틱에 여러 오브젝트들의 월드 변환 매트릭스는 서로 다르지만, 뷰 매트릭스는 동일하므로, 오브젝트의 정보를 담는 버퍼와 카메라 정보를 담는 버퍼를 분리하여 뷰 매트릭스의 중복 업데이트를 방지.
* 카메라 이동 및 회전
  * 윈도우 메시지를 통해 키 입력을 받아 카메라 제어.
* 추가 사항
  * 과도한 설계로 인해 많은 시간이 소요되었고, 그로 인해 구현 과정에서 발생한 문제를 해결하지 못하였음.

## UV, Billboard, Bounding Box, Batch Line
* 월드 좌표계
  * Left Hand, Z up 좌표계로 변환환. (DirectX는 Left Hand, Y up)
* UV
  * UV 값을 조절하여 텍스처 아틀라스에서 원하는 이미지 출력.
  * SubUV를 통해 시간에 따라 다른 이미지 출력.
* Billboard
  * Quad를 생성하고, 카메라를 바라보도록 회전.
  * 초기에는 카메라의 월드 스페이스를 바라보도록 회전하였으나, 화면 가장자리에서의 어색한 회전 때문에 Screen Aligned Quad 방식으로 변경.
* Batch Line
  * 일정 크기의 버퍼를 미리 생성한 후, 더 많은 라인을 그려야하는 경우에 더 큰 크기의 버퍼를 할당 받는 방식.
  * 배치 라인을 통한 월드 그리드 렌더.
    * 카메라와 거리가 멀수록 자연스럽게 Fade out 되도록 구현.
  * Debug Line Trace 기능을 통해 라인 트레이싱 결과 시각화.

## OBJ 파일 파싱을 통한 Static Mesh 임포트, 다중 뷰포트
* 여러 머티리얼이 포함되어있는 스태틱 메시 렌더
  * obj, mtl 파일 파싱.
  * 하나의 스태틱 메시를 머티리얼에 따라 나누어서 하나씩 렌더.
* 다중 뷰포트
  * `SWindow`, `SSpliter`를 통해 화면을 4등분.
  * 스플리터를 마우스로 드래그하려 창 크기를 조절 가능하게 구현.
* 추가 사항
  * 뷰포트 구현 과정에서 정돈된 구조를 위해 구조를 먼저 설계하는 탑다운 방식으로 접근.
  * Screen Aligned Quad를 4개 그려서 각 쿼드에 해당하는 뷰포트의 렌더 결과 텍스처를 입히는 방식 시도.
  * 하지만 시간이 많이 소요되었고, 세부 구현 과정에서 구조의 문제가 발견되어 정해진 시간 안에 구현하지 못하였음.
  * 커리큘럼 특성 상 짧은 시간 안에 구현해야 하므로, 탑다운 방식 보다는 바텀업 또는 그 사이의 균형이 중요하다는 점을 깨닫게 되었음.
  * 하지만, Screen Aligned Quad를 통해 뷰포트 렌더 텍스처를 띄우는 접근 방식은 추후 렌더 패스를 설계하는 과정에서 큰 도움이 되었음.

## 게임 잼 - Brute Force Competition
* 수만개의 스태틱 메시를 DrawInstance를 사용하지 않고 최적화.
  * 머티리얼 정렬, Frustum culling, Octree, BVH 도입.
  * 카메라의 트랜스폼이 바뀌지 않는 경우 기존의 렌더 결과를 재사용하는 방법 시도. (Screen Aligned Quad 및 Shader Resource View)

## PIE (Play In Editor)
* `UObject`의 `Duplicate`를 통해 에디터에 배치된 오브젝트들을 PIE 모드 진입 시 복제하여 플레이.
  * `AActor`의 경우 소유하고있는 `UActorComponent`들을 깊은 복사.
  * 모든 `UObject`들의 `Duplicate`함수를 작성하는 방식으로 접근. (유일했던 방식)

## Pixel Shader (Fog, Post Process)
* Post Process
  * 씬 렌더 과정에서 작성된 정보를 활용하여 포스트 프로세싱.
  * Screen Aligned Quad를 통해 씬 컬러와 포스트 프로세스 텍스처를 합성.
* Scene Depth 뷰모드
  * 씬 렌더 과정에서 작성된 Depth Stencil 버퍼를 읽어서 Z 값을 선형화 및 normalize하여 표시.
* Fog
  * Depth Stencil 버퍼의 Z값 및 텍스처의 UV를 통해 월드 포지션 정보를 복구.
  * 카메라와의 거리를 비교하여 Fog Factor를 계산하여 포스트 프로세스 텍스처의 알파 채널에 작성.
  * 이후 씬 컬러와 포스트 프로세스 텍스처를 합성하는 과정에서 Fog Factor를 통해 안개의 양 조절.
* Fire ball
  * 기초적인 포인트 라이트 구현.
* 추가 사항
  * 스태틱 메시 정점의 탄젠트를 계산하여 노멀맵 적용.

## Light
 * 